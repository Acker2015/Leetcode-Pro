package lt_600_699;

/**
 *
 * [650] 2 Keys Keyboard
 *
 *  最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：

     Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
     Paste (粘贴) : 你可以粘贴你上一次复制的字符。
     给定一个数字 n。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。
 */
public class LC_650 {
    /**
     * 方法一
     * DP
     * 1. 设计状态f(i),表示构成i个A所需要的最小步数，注意这里只需要计算是n的约数的状态，即状态i,满足n%i==0
     * 2. 初始时，f(1)=0, 其余为正无穷，每一次转移时，枚举i非自身的约数j，即i%j==0并且i!=j,
     *    则有 f(i) = f(j) + i/j;
     * 3. 最终答案为f(n)
     *
     * 时间复杂度
     * 状态数有 O(sqrt(n))个，每个状态的转移有 O(sqrt(n))个，故总时间复杂度为 O(n)。
     * @param n
     * @return
     */
    public int minSteps(int n) {
        int[] f = new int[n+1];
        for (int i = 2; i <= n; ++i) {
            f[i] = i;
            for (int j = 2; j*j <= n; ++j) {
                if (i%j == 0) {
                    f[i] = Math.min(f[i], f[j] + i/j);
                }
            }
        }
        return f[n];
    }

    /**
     * 方法二
     * 数学方法
     *
     * 1. 假设已经得到了 n 的所有质因数 a1,a2,…,ai，则n 的分解方式可能如下：最后一步必定是由 a1 组 n/a1 个 A 拷贝粘贴而成；
     * 同理，倒数第二步一定是由 a2 组 n/a1/a2 个A拷贝粘贴而成；直到第一步为止。
     * 可以发现不管分解的顺序如何，最终答案都是质因数之和。核心思想即粘贴的次数为质数次，否则可以有更有的分解方式。
     *
     * 2. 简要证明如下，设当前组成某个长度的字符串需要p步，若直接拷贝达到目标需要q次粘贴，总共需要p+q步完成；
     * 若q为合数，即 q=ij 且 i>1,j>1，则可以将拷贝分解为两次，先复制拷贝i次，然后再复制拷贝j次，这样需要 p+i+j 步完成，显然 ij>=i+j。所以只需要所有质因数累加即可。
     * @param n
     * @return
     */
    public int minSteps2(int n) {
        int ans = 0;
        int i = 2;
        while (n > 1) {
            while (n % i == 0) {
                n /= i;
                ans += i;
            }
            i++;
        }
        return ans;
    }



}
